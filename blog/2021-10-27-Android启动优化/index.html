<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 5.4.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://cdn.jsdelivr.net'>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  <title>App启动速度 - Mark</title>

  
    <meta name="description" content="应用启动速度一个应用App的启动速度能够影响用户的首次体验，启动速度较慢(感官上)的应用可能导致用户再次开启App的意图下降，或者卸载放弃该应用程序。 我们将从两个方向优化应用的启动速度1.视觉体验优化 2.代码逻辑优化 视觉优化谷歌开发文档. 应用程序启动有三种状态，每种状态都会影响应用程序对用户可见所需的时间：冷启动，热启动和温启动。  在冷启动时，应用程序从头开始。在其他状态下，系统需要将正">
<meta property="og:type" content="article">
<meta property="og:title" content="App启动速度">
<meta property="og:url" content="http://liwentuo.github.io/blog/2021-10-27-Android%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/">
<meta property="og:site_name" content="Mark">
<meta property="og:description" content="应用启动速度一个应用App的启动速度能够影响用户的首次体验，启动速度较慢(感官上)的应用可能导致用户再次开启App的意图下降，或者卸载放弃该应用程序。 我们将从两个方向优化应用的启动速度1.视觉体验优化 2.代码逻辑优化 视觉优化谷歌开发文档. 应用程序启动有三种状态，每种状态都会影响应用程序对用户可见所需的时间：冷启动，热启动和温启动。  在冷启动时，应用程序从头开始。在其他状态下，系统需要将正">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/10/27/2TNsg4JHQjLEU6W.png">
<meta property="og:image" content="https://i.loli.net/2021/10/27/hBo7LaTkStNpyrE.png">
<meta property="og:image" content="https://i.loli.net/2021/10/27/UrfIZzF9vniKg32.png">
<meta property="og:image" content="https://i.loli.net/2021/10/27/yhxIbU6FdKXouS5.png">
<meta property="og:image" content="https://i.loli.net/2021/10/27/qv1IMl6ywN5rkDT.jpg">
<meta property="og:image" content="https://i.loli.net/2021/10/27/Zf3PagJ9hBArdL4.png">
<meta property="article:published_time" content="2021-10-09T16:00:00.000Z">
<meta property="article:modified_time" content="2021-10-09T16:00:00.000Z">
<meta property="article:author" content="david">
<meta property="article:tag" content="Android性能优化">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/10/27/2TNsg4JHQjLEU6W.png">
  
  

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="Mark" type="application/atom+xml">
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  
</head>

<body>
  


  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    


<header class="header">

<div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.2/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="https://i.loli.net/2021/09/22/hsX8ka5zQJeGDUb.jpg" onerror="javascript:this.classList.add('error');this.src='https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/image/2659360.svg';"></a><a class="title" href="/"><div class="main">Mark</div><div class="sub normal cap">Daivd</div><div class="sub hover cap" style="opacity:0">angle.lwt@qq.com</div></a></div>
<nav class="menu dis-select"><a class="nav-item active" href="/">博客</a><a class="nav-item" href="/wiki/">项目</a><a class="nav-item" href="/notes/">便笺</a><a class="nav-item" href="/about/">关于Mark</a></nav></header>

<div class="widgets">

<div class="widget-wrap single" id="toc"><div class="widget-header cap dis-select"><span class="name">本文目录</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6"><span class="toc-text">应用启动速度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%91%E4%BB%AC%E5%B0%86%E4%BB%8E%E4%B8%A4%E4%B8%AA%E6%96%B9%E5%90%91%E4%BC%98%E5%8C%96%E5%BA%94%E7%94%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6"><span class="toc-text">我们将从两个方向优化应用的启动速度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E8%A7%89%E4%BC%98%E5%8C%96"><span class="toc-text">视觉优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96"><span class="toc-text">启动主题优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%BB%98%E8%AE%A4%E6%83%85%E5%86%B5"><span class="toc-text">1.默认情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E9%80%8F%E6%98%8E%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96"><span class="toc-text">2.透明主题优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%AE%BE%E7%BD%AE%E9%97%AA%E5%B1%8F%E5%9B%BE%E7%89%87%E4%B8%BB%E9%A2%98"><span class="toc-text">3.设置闪屏图片主题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96"><span class="toc-text">代码优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96-1"><span class="toc-text">代码优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Application-%E4%BC%98%E5%8C%96"><span class="toc-text">Application 优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AA%E5%B1%8F%E9%A1%B5%E4%B8%9A%E5%8A%A1%E4%BC%98%E5%8C%96"><span class="toc-text">闪屏页业务优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E5%91%8A%E9%A1%B5%E4%BC%98%E5%8C%96"><span class="toc-text">广告页优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-text">启动窗口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li></ol></div></div></div>


</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" title="GitHub" href="https://github.com/liwentuo" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.3/social/08a41b181ce68.svg"/></a><a class="social" title="Unsplash" href="https://unsplash.com/@angledaivd" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.3/social/3616429.svg"/></a><a class="social" title="Comments" href="/about/#comments" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.3/social/942ebbf1a4b91.svg"/></a></div></footer>

    </aside>
    <div class='l_main'>
      

      


<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">Mark</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/blog/categories/android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">Android性能优化</a></div><div id="post-meta">发布于&nbsp;<time datetime="2021-10-09T16:00:00.000Z">2021年10月10日</time></div></div>

<article class='content md post'>
<h1 class="article-title"><span>App启动速度</span></h1>
<h2 id="应用启动速度"><a href="#应用启动速度" class="headerlink" title="应用启动速度"></a>应用启动速度</h2><p>一个应用App的启动速度能够影响用户的首次体验，启动速度较慢(感官上)的应用可能导致用户再次开启App的意图下降，或者卸载放弃该应用程序。</p>
<h2 id="我们将从两个方向优化应用的启动速度"><a href="#我们将从两个方向优化应用的启动速度" class="headerlink" title="我们将从两个方向优化应用的启动速度"></a>我们将从两个方向优化应用的启动速度</h2><p>1.视觉体验优化</p>
<p>2.代码逻辑优化</p>
<h3 id="视觉优化"><a href="#视觉优化" class="headerlink" title="视觉优化"></a>视觉优化</h3><p>谷歌开发文档.</p>
<p>应用程序启动有三种状态，每种状态都会影响应用程序对用户可见所需的时间：冷启动，热启动和温启动。</p>
<blockquote>
<p>在冷启动时，应用程序从头开始。在其他状态下，系统需要将正在运行的应用程序从后台运行到前台。我们建议您始终根据冷启动的假设进行优化。这样做也可以改善热启动和温启动的性能。</p>
</blockquote>
<p>在冷启动开始时，系统有三个任务。这些任务是：</p>
<ul>
<li>加载并启动应用程序。</li>
<li>启动后立即显示应用程序空白的启动窗口。</li>
<li>创建应用程序进程。</li>
</ul>
<blockquote>
<p>一旦系统创建应用程序进程，应用程序进程就会负责下一阶段。这些阶段是：</p>
</blockquote>
<ul>
<li><p>创建app对象.</p>
</li>
<li><p>启动主线程(main thread).</p>
</li>
<li><p>创建应用入口的Activity对象.</p>
</li>
<li><p>填充加载布局Views</p>
</li>
<li><p>在屏幕上执行View的绘制过程.measure -&gt; layout -&gt; draw</p>
</li>
</ul>
<blockquote>
<p>应用程序进程完成第一次绘制后，系统进程会交换当前显示的背景窗口，将其替换为主活动。此时，用户可以开始使用该应用程序。</p>
</blockquote>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.loli.net/2021/10/27/2TNsg4JHQjLEU6W.png"></p>
<p>因为App应用进程的创建过程是由手机的软硬件决定的，所以我们只能在这个创建过程中视觉优化。</p>
<hr>
<h4 id="启动主题优化"><a href="#启动主题优化" class="headerlink" title="启动主题优化"></a>启动主题优化</h4><p>冷启动阶段 :</p>
<p>加载并启动应用程序。<br>启动后立即显示应用程序空白的启动窗口。<br>创建应用程序进程。<br>所谓的主题优化，就是应用程序在冷启动的时候(1~2阶段)，设置启动窗口的主题。</p>
<p>因为现在 App 应用启动都会先进入一个闪屏页(LaunchActivity) 来展示应用信息。</p>
<h5 id="1-默认情况"><a href="#1-默认情况" class="headerlink" title="1.默认情况"></a>1.默认情况</h5><p>如果我们对App没有做处理(设置了默认主题)，并且在 Application 初始化了其它第三方的服务(假设需要加载2000ms)，那么冷启动过程就会如b白屏</p>
<p>系统默认会在启动应用程序的时候 启动空白窗口 ，直到 App 应用程序的入口 Activity 创建成功，视图绘制完毕。( 大概是onWindowFocusChanged方法回调的时候 )</p>
<h5 id="2-透明主题优化"><a href="#2-透明主题优化" class="headerlink" title="2.透明主题优化"></a>2.透明主题优化</h5><p>为了解决启动窗口白屏问题，许多开发者使用透明主题来解决这个问题，但是治标不治本。</p>
<p>虽然解决了上面这个问题，但是仍然有些不足。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Base application theme. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;AppTheme&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Theme.AppCompat.Light.DarkActionBar&quot;</span>&gt;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowFullscreen&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowIsTranslucent&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>(无白屏,不过从点击到App仍然存在视觉延迟~)</p>
<h5 id="3-设置闪屏图片主题"><a href="#3-设置闪屏图片主题" class="headerlink" title="3.设置闪屏图片主题"></a>3.设置闪屏图片主题</h5><p>为了更顺滑无缝衔接我们的闪屏页，可以在启动 Activity 的 Theme中设置闪屏页图片，这样启动窗口的图片就会是闪屏页图片，而不是白屏。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;AppTheme&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Theme.AppCompat.Light.NoActionBar&quot;</span>&gt;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowBackground&quot;</span>&gt;</span>@drawable/lunch<span class="tag">&lt;/<span class="name">item</span>&gt;</span>  //闪屏页图片</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowFullscreen&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowDrawsSystemBarBackgrounds&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">item</span>&gt;</span><span class="comment">&lt;!--显示虚拟按键，并腾出空间--&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>这样设置的话，就会在冷启动的时候，展示闪屏页的图片，等App进程初始化加载入口 Activity (也是闪屏页) 就可以无缝衔接。</p>
<p>其实这种方式并没有真正的加速应用进程的启动速度，而只是通过用户视觉效果带来的优化体验。</p>
<hr>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>当然上面使用设置主题的方式优化用户体验效果治标不治本，关键还在于对代码的优化。</p>
<p>首先我们可以统计一下应用冷启动的时间。</p>
<p>冷启动耗时统计<br>adb 命令统计<br><a target="_blank" rel="noopener" href="https://www.androidperformance.com/2015/12/31/How-to-calculation-android-app-lunch-time/#2-1-%E7%B3%BB%E7%BB%9F%E9%83%A8%E5%88%86">参考如何计算 App 的启动时间</a><br>adb命令 : adb shell am start -S -W 包名/启动类的全限定名 ， -S 表示重启当前应用<br><a href="">更多adb命令</a></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">C:<span class="keyword">\Android</span><span class="keyword">\Demo</span>&gt;adb shell am start -S -W com.example.moneyqian.demo/com.example.moneyqian.demo.MainActivity</span><br><span class="line">Stopping: com.example.moneyqian.demo</span><br><span class="line">Starting: Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.example.moneyqian.demo/.MainActivity &#125;</span><br><span class="line">Status: ok</span><br><span class="line">Activity: com.example.moneyqian.demo/.MainActivity</span><br><span class="line">ThisTime: 2247</span><br><span class="line">TotalTime: 2247</span><br><span class="line">WaitTime: 2278</span><br><span class="line">Complete</span><br></pre></td></tr></table></figure>

<p><code>ThisTime</code> : 最后一个 Activity 的启动耗时(例如从 LaunchActivity - &gt;MainActivity「adb命令输入的Activity」 , 只统计 MainActivity 的启动耗时)<br><code>TotalTime</code> : 启动一连串的 Activity 总耗时.(有几个Activity 就统计几个)<br><code>WaitTime</code> : 应用进程的创建过程 + TotalTime .</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.loli.net/2021/10/27/hBo7LaTkStNpyrE.png"></p>
<p>在第①个时间段内，AMS 创建 ActivityRecord 记录块和选择合理的 Task、将当前Resume 的 Activity 进行 pause.<br>在第②个时间段内，启动进程、调用无界面 Activity 的 onCreate() 等、 pause/finish 无界面的 Activity.<br>在第③个时间段内，调用有界面 Activity 的 onCreate、onResume.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ActivityRecord</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportLaunchTimeLocked</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> curTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> thisTime = curTime - displayStartTime;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> totalTime = stack.mLaunchStartTime != <span class="number">0</span> ? (curTime - stack.mLaunchStartTime) : thisTime;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<p>最后总结一下 ： 如果需要统计从点击桌面图标到 Activity 启动完毕，可以用WaitTime作为标准，但是系统的启动时间优化不了，所以优化冷启动我们只要在意<code>ThisTime</code>即可。</p>
<p>系统日志统计<br>另外也可以根据系统日志来统计启动耗时，在Android Studio中查找已用时间，必须在logcat视图中禁用过滤器(No Filters)。因为这个是系统的日志输出，而不是应用程序的。你也可以查看其它应用程序的启动耗时。</p>
<p>过滤<code>displayed</code>输出的启动日志.</p>
<h4 id="代码优化-1"><a href="#代码优化-1" class="headerlink" title="代码优化"></a>代码优化</h4><p>根据上面启动时间的输出统计，我们就可以先记录优化前的冷启动耗时，然后再对比优化之后的启动时间。</p>
<h4 id="Application-优化"><a href="#Application-优化" class="headerlink" title="Application 优化"></a>Application 优化</h4><p>Application 作为 应用程序的整个初始化配置入口，时常担负着它不应该有的负担~</p>
<p>有很多第三方组件（包括App应用本身）都在 Application 中抢占先机，完成初始化操作。</p>
<p>但是在 Application 中完成繁重的初始化操作和复杂的逻辑就会影响到应用的启动性能</p>
<p>通常，有机会优化这些工作以实现性能改进，这些常见问题包括：</p>
<p>1.复杂繁琐的布局初始化<br>2.阻塞主线程 UI 绘制的操作，如 I/O 读写或者是网络访问.<br>3.Bitmap 大图片或者 VectorDrawable加载<br>4.其它占用主线程的操作<br>我们可以根据这些组件的轻重缓急之分，对初始化做一下分类 ：</p>
<p>1.必要的组件一定要在主线程中立即初始化(入口 Activity 可能立即会用到)<br>2.组件一定要在主线程中初始化，但是可以延迟初始化。<br>3.组件可以在子线程中初始化。<br><code>放在子线程的组件初始化建议延迟初始化 </code>，这样就可以了解是否会对项目造成影响！</p>
<p>所以对于上面的分析，我们可以在项目中 Application 的加载组件进行如下优化 ：</p>
<p>将<code>Bugly</code>，<code>x5</code>内核初始化，SP的读写，友盟等组件放到子线程中初始化。（子线程初始化不能影响到组件的使用）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="comment">//设置线程的优先级，不与主线程抢资源</span></span><br><span class="line">             Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">    <span class="comment">//子线程初始化第三方组件</span></span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);<span class="comment">//建议延迟初始化，可以发现是否影响其它功能，或者是崩溃！</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;).start();</span><br></pre></td></tr></table></figure>


<p>将需要在主线程中初始化但是可以不用立即完成的动作延迟加载（原本是想在入口 Activity 中进行此项操作，不过组件的初始化放在 Application 中统一管理为妙.）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">handler.postDelayed(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//延迟初始化组件</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<h4 id="闪屏页业务优化"><a href="#闪屏页业务优化" class="headerlink" title="闪屏页业务优化"></a>闪屏页业务优化</h4><p>最后还剩下那些为数不多的组件在主线程初始化动作，例如埋点，点击流，数据库初始化等，不过这些消耗的时间可以在其它地方相抵。</p>
<p>需求背景 ： 应用App通常会设置一个固定的闪屏页展示时间，例如2000ms，所以我们可以根据用户手机的运行速度，对展示时间做出调整，但是总时间仍然为 2000ms。</p>
<p><code>闪屏页政展示总时间 = 组件初始化时间 + 剩余展示时间</code>。</p>
<p>也就是2000ms的总时间，组件初始化了800ms，那么就再展示1200ms即可。</p>
<p>我们先了解一下 Application的启动过程，<br>虽然这个以下图片的源码并不是最新源码（5.0源码），不过不影响整体流程。（7.0,8.0方法名会有所改变）。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.loli.net/2021/10/27/UrfIZzF9vniKg32.png"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.loli.net/2021/10/27/yhxIbU6FdKXouS5.png"></p>
<p>冷启动的过程中系统会初始化应用程序进程，创建Application等任务，这时候会展示一个 启动窗口 Starting Window，上面分析了过，如果没有优化主题的话，那么就是白屏。</p>
<p>如果要了解更多启动过程源码，可以看我的博客 ： Launcher 启动 Activity 的工作过程</p>
<p>分析源码后，我们可以知道 Application 初始化后会调用 <code>attachBaseContext() </code>方法，再调用 <code>Application </code>的 <code>onCreate()</code>，再到入口 <code>Activity</code>的创建和执行 <code>onCreate()</code> 方法。所以我们就可以在 Application 中记录启动时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Application</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.attachBaseContext(base);</span><br><span class="line">    SPUtil.putLong(<span class="string">&quot;application_attach_time&quot;</span>, System.currentTimeMillis());<span class="comment">//记录Application初始化时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了启动时间，我们得知道入口的 Acitivty 显示给用户的时间（View绘制完毕），在博客（ View的工作流程）中了解到，在<code>onWindowFocusChanged()</code>的回调时机中表示可以获取用户的触摸时间和View的流程绘制完毕，所以我们可以在这个方法里记录显示时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//入口Activity</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasFocus)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onWindowFocusChanged(hasFocus);</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">long</span> appAttachTime = SPUtil.getLong(<span class="string">&quot;application_attach_time&quot;</span>);</span><br><span class="line">      <span class="keyword">long</span> diffTime = System.currentTimeMillis() - appAttachTime;<span class="comment">//从application到入口Acitity的时间</span></span><br><span class="line"> </span><br><span class="line">     <span class="comment">//所以闪屏页展示的时间为 2000ms - diffTime.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>所以我们就可以动态的设置应用闪屏的显示时间，尽量让每一部手机展示的时间一致，这样就不会让手机配置较低的用户感觉漫长难熬的闪屏页时间（例如初始化了2000ms，又要展示2000ms的闪屏页时间.），优化用户体验。</p>
<h4 id="广告页优化"><a href="#广告页优化" class="headerlink" title="广告页优化"></a>广告页优化</h4><p>闪屏页过后就要展示金主爸爸们的广告页了。</p>
<p>因为项目中广告页图片有可能是大图，APng动态图片，所以需要将这些图片下载到本地文件，下载完成后再显示，这个过程往往会遇到以下两个问题 ：</p>
<p>广告页的下载，由于这个是一个异步过程，所以往往不知道加载到页面的合适时机。<br>广告页的保存，因为保存是 I/O 流操作，很有可能被用户中断，下次拿到破损的图片。<br>因为不清楚用户的网络环境，有些用户下载广告页可能需要一段时间，这时候又不可能无限的等候。所以针对这个问题我们可以开启 IntentService 用来下载广告页图片。</p>
<p>在入口 Acitivity 中开启 IntentService 来下载广告页。 或者是其它异步下载操作。<br>在广告页图片 文件流完全写入后 记录图片大小，或者记录一个标识。<br>在下次的广告页加载中可以判断是否已经下载好了广告页图片以及图片是否完整，否则删除并且再次下载图片。</p>
<p>另外因为在闪屏页中仍然有 剩余展示时间，所以在这个时间段里如果用户已经下载好了图片并且图片完整，就可以显示广告页。否则进入主 Activity ， 因为 IntentService 仍然在后台继续默默的下载并保存图片~</p>
<h4 id="启动窗口"><a href="#启动窗口" class="headerlink" title="启动窗口"></a>启动窗口</h4><p>优化完我们的代码后，分析一下启动窗口的源码。基于 android-25 (7.1.1)</p>
<p>启动窗口是由 <code>WindowManagerService </code>统一管理的<code> Window</code>窗口，一般作为冷启动页入口 Activity 的预览窗口，启动窗口由 <code>ActivityManagerService </code>来决定是否显示的，并不是每一个<code> Activity</code> 的启动和跳转都会显示这个窗口。</p>
<p><code>WindowManagerService </code>通过窗口管理策略类<code>PhoneWindowManager</code>来创建启动窗口。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.loli.net/2021/10/27/qv1IMl6ywN5rkDT.jpg"></p>
<p>直奔主题，在 ActivityStarter的startActivityUnchecked()方法中，调用了ActivityStack（Activity 状态管理）的startActivityLocked()方法。此时Activity 还在启动过程中，窗口并未显示。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://i.loli.net/2021/10/27/Zf3PagJ9hBArdL4.png"></p>
<p>先上一张流程图，展示了启动窗口的显示过程。</p>
<p>首先，由 Activity 状态管理者ActivityStack开始执行显示启动窗口的流程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ActivityStack</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startActivityLocked</span><span class="params">(ActivityRecord r, <span class="keyword">boolean</span> newTask, <span class="keyword">boolean</span> keepCurTransition,</span></span></span><br><span class="line"><span class="params"><span class="function">            ActivityOptions options)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isHomeStack() || numActivities() &gt; <span class="number">0</span>) &#123;<span class="comment">//HOME_STACK表示Launcher桌面所在的Stack</span></span><br><span class="line">            <span class="comment">// 1.首先当前启动栈不在Launcher的桌面栈里,并且当前系统已经有激活过Activity</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// We want to show the starting preview window if we are</span></span><br><span class="line">            <span class="comment">// switching to a new task, or the next activity&#x27;s process is</span></span><br><span class="line">            <span class="comment">// not currently running.</span></span><br><span class="line">    </span><br><span class="line">            <span class="keyword">boolean</span> doShow = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (newTask) &#123;</span><br><span class="line">                <span class="comment">// 2.要将该Activity组件放在一个新的任务栈中启动</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Even though this activity is starting fresh, we still need</span></span><br><span class="line">                <span class="comment">// to reset it to make sure we apply affinities to move any</span></span><br><span class="line">                <span class="comment">// existing activities from other tasks in to it.</span></span><br><span class="line">                <span class="keyword">if</span> ((r.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != <span class="number">0</span>) &#123;</span><br><span class="line">                    resetTaskIfNeededLocked(r, r);</span><br><span class="line">                    doShow = topRunningNonDelayedActivityLocked(<span class="keyword">null</span>) == r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options != <span class="keyword">null</span> &amp;&amp; options.getAnimationType()</span><br><span class="line">                    == ActivityOptions.ANIM_SCENE_TRANSITION) &#123;</span><br><span class="line">                doShow = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r.mLaunchTaskBehind) &#123;</span><br><span class="line">                <span class="comment">//3. 热启动，不需要启动窗口</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Don&#x27;t do a starting window for mLaunchTaskBehind. More importantly make sure we</span></span><br><span class="line">                <span class="comment">// tell WindowManager that r is visible even though it is at the back of the stack.</span></span><br><span class="line">                mWindowManager.setAppVisibility(r.appToken, <span class="keyword">true</span>);</span><br><span class="line">                ensureActivitiesVisibleLocked(<span class="keyword">null</span>, <span class="number">0</span>, !PRESERVE_WINDOWS);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SHOW_APP_STARTING_PREVIEW &amp;&amp; doShow) &#123;</span><br><span class="line">                <span class="comment">//4. 显示启动窗口</span></span><br><span class="line">                r.showStartingWindow(prev, showStartingIcon);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前启动的是桌面Launcher (开机启动)</span></span><br><span class="line">            <span class="comment">// If this is the first activity, don&#x27;t do any fancy animations,</span></span><br><span class="line">            <span class="comment">// because there is nothing for it to animate on top of.</span></span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>1.首先判断当前要启动的 Activity 不在Launcher栈里<br>2.要启动的 Activity 是否处于新的 Task 里，并且没有转场动画<br>3.如果是热/温启动则不需要启动窗口，直接设置App的Visibility</p>
<p>接下来调用 <code>ActivityRecord</code> 的<code>showStartingWindow()</code>方法来设置启动窗口并且改变当前窗口的状态。</p>
<p>如果<code> App</code> 的应用进程创建完成，并且入口<code>Activity</code>准备就绪，就可以根据<code> mStartingWindowState</code> 来判断是否需要关闭启动窗口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ActivityRecord</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showStartingWindow</span><span class="params">(ActivityRecord prev, <span class="keyword">boolean</span> createIfNeeded)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CompatibilityInfo compatInfo =</span><br><span class="line">                service.compatibilityInfoForPackageLocked(info.applicationInfo);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> shown = service.mWindowManager.setAppStartingWindow(</span><br><span class="line">                appToken, packageName, theme, compatInfo, nonLocalizedLabel, labelRes, icon,</span><br><span class="line">                logo, windowFlags, prev != <span class="keyword">null</span> ? prev.appToken : <span class="keyword">null</span>, createIfNeeded);</span><br><span class="line">        <span class="keyword">if</span> (shown) &#123;</span><br><span class="line">            mStartingWindowState = STARTING_WINDOW_SHOWN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>WindowManagerService 会对当前 Activity 的token和主题进行判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//WindowManagerService</span></span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setAppStartingWindow</span><span class="params">(IBinder token, String pkg,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">int</span> theme, CompatibilityInfo compatInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">            CharSequence nonLocalizedLabel, <span class="keyword">int</span> labelRes, <span class="keyword">int</span> icon, <span class="keyword">int</span> logo,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">int</span> windowFlags, IBinder transferFrom, <span class="keyword">boolean</span> createIfNeeded)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">    </span><br><span class="line">    		<span class="comment">//1. 启动窗口也是需要token的</span></span><br><span class="line">            AppWindowToken wtoken = findAppWindowToken(token);</span><br><span class="line">            </span><br><span class="line">    		<span class="comment">//2. 如果已经设置过启动窗口了，不继续处理</span></span><br><span class="line">            <span class="keyword">if</span> (wtoken.startingData != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// If this is a translucent window, then don&#x27;t</span></span><br><span class="line">            <span class="comment">// show a starting window -- the current effect (a full-screen</span></span><br><span class="line">            <span class="comment">// opaque starting window that fades away to the real contents</span></span><br><span class="line">            <span class="comment">// when it is ready) does not work for this.</span></span><br><span class="line">            <span class="keyword">if</span> (theme != <span class="number">0</span>) &#123;</span><br><span class="line">                AttributeCache.Entry ent = AttributeCache.instance().get(pkg, theme,</span><br><span class="line">                        com.android.internal.R.styleable.Window, mCurrentUserId);</span><br><span class="line">                        </span><br><span class="line">               <span class="comment">//3. 一堆代码对主题判断，不符合要求则不显示启动窗口（如透明主题）</span></span><br><span class="line">                <span class="keyword">if</span> (windowIsTranslucent) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (windowIsFloating || windowDisableStarting) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//4. 创建StartingData，并且通过Handler发送消息</span></span><br><span class="line"></span><br><span class="line">        wtoken.startingData = <span class="keyword">new</span> StartingData(pkg, theme, compatInfo, nonLocalizedLabel,</span><br><span class="line">                labelRes, icon, logo, windowFlags);</span><br><span class="line">        Message m = mH.obtainMessage(H.ADD_STARTING, wtoken);</span><br><span class="line">        <span class="comment">// Note: we really want to do sendMessageAtFrontOfQueue() because we</span></span><br><span class="line">        <span class="comment">// want to process the message ASAP, before any other queued</span></span><br><span class="line">        <span class="comment">// messages.</span></span><br><span class="line"></span><br><span class="line">        mH.sendMessageAtFrontOfQueue(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">    			``````</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>启动窗口也需要和 Activity 拥有同样令牌 token ，虽然启动窗口可能是白屏，或者一张图片，但是仍然需要走绘制流程已经通过WMS显示窗口。</span><br><span class="line"><span class="number">2.</span>StartingData对象用来表示启动窗口的相关数据，描述了启动窗口的视图信息。</span><br><span class="line"><span class="number">3.</span>如果当前 Activity 是`透明主题`或者是`浮动窗口`等，那么就不需要启动窗口来过渡启动过程，`所以在上面视觉优化中的设置透明主题就没有显示白色的启动窗口`。</span><br><span class="line"><span class="number">4.</span>显示启动窗口也是一件心急火燎的事情，WMS的内部类`H `(handler) 处于主线程处理消息，所以需要将当前Message放置队列头部。</span><br><span class="line">PS : 为什么需要通过 Handler 发送消息 ？</span><br><span class="line">你可以在各大服务Service中见到 Handler 的身影，并且它们可能都有一个很吊的命名` H` ，因为可能调用这个服务的某个执行方法处于子线程中，所以 Handler 的职责就是将它们切换到主线程中，并且也可以统一管理调度。更多 Handler 了解可以查阅文章 ： 你真的了解Handler？</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"></span><br><span class="line"><span class="comment">//WindowManagerService --&gt; H </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> ADD_STARTING: &#123;</span><br><span class="line">                <span class="keyword">final</span> AppWindowToken wtoken = (AppWindowToken)msg.obj;</span><br><span class="line">                <span class="keyword">final</span> StartingData sd = wtoken.startingData;</span><br><span class="line"></span><br><span class="line">                View view = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> Configuration overrideConfig = wtoken != <span class="keyword">null</span> &amp;&amp; wtoken.mTask != <span class="keyword">null</span></span><br><span class="line">                            ? wtoken.mTask.mOverrideConfig : <span class="keyword">null</span>;</span><br><span class="line">                    view = mPolicy.addStartingWindow(wtoken.token, sd.pkg, sd.theme,</span><br><span class="line">                        sd.compatInfo, sd.nonLocalizedLabel, sd.labelRes, sd.icon, sd.logo,</span><br><span class="line">                        sd.windowFlags, overrideConfig);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    Slog.w(TAG_WM, <span class="string">&quot;Exception when adding starting window&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">             &#125; </span><br><span class="line">             </span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>在当前的<code>handleMessage</code>方法中，会处于主线程处理消息，拿到token和StartingData启动数据后，便通过<code>mPolicy.addStartingWindow()</code>方法将启动窗口添加到WIndow上。</p>
<p><code>mPolicy</code>为<code>PhoneWindowManager</code>，控制着启动窗口的添加删除和修改。</p>
<p>在PhoneWindowManager对启动窗口进行配置，获取当前Activity设置的主题和资源信息，设置到启动窗口中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PhoneWindowManager</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">addStartingWindow</span><span class="params">(IBinder appToken, String packageName, <span class="keyword">int</span> theme,</span></span></span><br><span class="line"><span class="params"><span class="function">            CompatibilityInfo compatInfo, CharSequence nonLocalizedLabel, <span class="keyword">int</span> labelRes,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">int</span> icon, <span class="keyword">int</span> logo, <span class="keyword">int</span> windowFlags, Configuration overrideConfig)</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line"><span class="comment">//可以通过SHOW_STARTING_ANIMATIONS设置不显示启动窗口</span></span><br><span class="line">    <span class="keyword">if</span> (!SHOW_STARTING_ANIMATIONS) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    WindowManager wm = <span class="keyword">null</span>;</span><br><span class="line">    View view = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1. 获取上下文Context和主题theme以及标题</span></span><br><span class="line">        Context context = mContext;</span><br><span class="line">        <span class="keyword">if</span> (theme != context.getThemeResId() || labelRes != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                context = context.createPackageContext(packageName, <span class="number">0</span>);</span><br><span class="line">                context.setTheme(theme);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 创建PhoneWindow 用来显示</span></span><br><span class="line">        <span class="keyword">final</span> PhoneWindow win = <span class="keyword">new</span> PhoneWindow(context);</span><br><span class="line">        win.setIsStartingWindow(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 设置当前窗口type和flag,源码注释中描述的很清晰...</span></span><br><span class="line">        win.setType(</span><br><span class="line">            WindowManager.LayoutParams.TYPE_APPLICATION_STARTING);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Force the window flags: this is a fake window, so it is not really</span></span><br><span class="line">        <span class="comment">// touchable or focusable by the user.  We also add in the ALT_FOCUSABLE_IM</span></span><br><span class="line">        <span class="comment">// flag because we do know that the next window will take input</span></span><br><span class="line">        <span class="comment">// focus, so we want to get the IME window up on top of us right away.</span></span><br><span class="line">        win.setFlags(</span><br><span class="line">            windowFlags|</span><br><span class="line">            WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE|</span><br><span class="line">            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE|</span><br><span class="line">            WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,</span><br><span class="line">            windowFlags|</span><br><span class="line">            WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE|</span><br><span class="line">            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE|</span><br><span class="line">            WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);</span><br><span class="line"></span><br><span class="line">        win.setLayout(WindowManager.LayoutParams.MATCH_PARENT,</span><br><span class="line">                WindowManager.LayoutParams.MATCH_PARENT);	</span><br><span class="line">        view = win.getDecorView();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. WindowManager的绘制流程</span></span><br><span class="line">        wm.addView(view, params);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view.getParent() != <span class="keyword">null</span> ? view : <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (WindowManager.BadTokenException e) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="comment">// don&#x27;t crash if something else bad happens, for example a</span></span><br><span class="line">        <span class="comment">// failure loading resources because we are loading from an app</span></span><br><span class="line">        <span class="comment">// on external storage that has been unmounted.</span></span><br><span class="line">        Log.w(TAG, appToken + <span class="string">&quot; failed creating starting window&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.如果theme和labelRes的值不为0，那么说明开发者指定了启动窗口的主题和标题，那么就需要从当前要启动的Activity中获取这些信息，并设置到启动窗口中。<br>2.和其它窗口一样，启动窗口也需要通过PhoneWindow来设置布局信息DecorView。所以在上面视觉优化中的设置闪屏图片主题的启动窗口显示的就是图片内容。<br>3.启动窗口和普通窗口的不同之处在于它是 fake window ，不需要触摸事件<br>4.最后通过WindowManger走View的绘制流程(measure-layout-draw)将启动窗口显示出来，最后会请求WindowManagerService为启动窗口添加一个WindowState对象，真正的将启动窗口显示给用户，并且可以对启动窗口进行管理。<br>更多WindowManager的addView流程可以查阅 ： <a target="_blank" rel="noopener" href="https://blog.csdn.net/qian520ao/article/details/78657084">View的工作流程</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此应用程序的启动优化和启动窗口的源码分析已经总结完毕，在项目的开发中要知其然而之所以然<br>，并且对源码的分析有助于我们了解原理和解决问题的根源。</p>


<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用署名-非商业性使用-相同方式共享 4.0 国际许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="header cap theme"><span>接下来阅读</span></section><section class="body fs14"><a id="next" href="/blog/2021-10-8-LiveData&Lifecycle/">LiveData&Lifecycle<span class="note">较早</span></a><div class="line"></div><a id="prev" href="/blog/2021-10-22-Window%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/">Windows 11程序员<span class="note">较新</span></a><div class="line"></div><a id="more" href="/blog/archives">检索全部文章</a></section></div>






  <div class='related-wrap md reveal' id="comments">
    <div class='cmt-title cap theme'>
      快来参与讨论吧
    </div>
    <div class='cmt-body beaudar'>
      

<svg class="loading" style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg>

<div id="beaudar" repo="liwentuo/blog-comments" issue-term="pathname" theme="preferred-color-scheme" input-position="top" comment-order="desc" loading="false" branch="main"></div>

    </div>
  </div>



      
<footer class="page-footer reveal fs12"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs14">博客</span><a href="/">近期发布</a><a href="/blog/categories/">分类</a><a href="/blog/tags/">标签</a><a href="/blog/archives/">归档</a></div><div class="sitemap-group"><span class="fs14">项目</span><a href="/wiki/tags/%E5%BC%80%E6%BA%90%E5%BA%93/">开源库</a><a href="/wiki/tags/%E5%AE%9E%E7%94%A8%E8%84%9A%E6%9C%AC/">实用脚本</a><a href="/wiki/tags/%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/">博客主题</a><a href="/wiki/tags/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/">应用程序</a></div><div class="sitemap-group"><span class="fs14">社交</span><a href="/friends/">友链</a><a href="/about/#comments">留言板</a></div><div class="sitemap-group"><span class="fs14">更多</span><a href="/about/">关于本站</a><a target="_blank" rel="noopener" href="https://github.com/liwentuo">GitHub</a></div></div><div class="text"><p>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
<p>本站由 <a href="http://liwentuo.github.io/">@david</a> 创建，使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.5.1" title="v1.5.1">Stellar</a> 作为主题。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.5.1';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js',
    sitesjs: '/js/plugins/sites.js',
    friendsjs: '/js/plugins/friends.js',
  };

  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.3.1/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@6/swiper-bundle.min.css","js":"https://unpkg.com/swiper@6/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://cdn.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->

  <script>
  function loadBeaudar() {
    const els = document.querySelectorAll("#comments #beaudar");
    if (els.length === 0) return;
    els.forEach((el, i) => {
      try {
        el.innerHTML = '';
      } catch (error) {
        console.log(error);
      }
      var script = document.createElement('script');
      script.src = 'https://beaudar.lipk.org/client.js';
      script.async = true;
      for (let key of Object.keys(el.attributes)) {
        let attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
    });
  }
  window.addEventListener('DOMContentLoaded', (event) => {
      loadBeaudar();
  });
</script>




<!-- inject -->


  </div>
</body>
</html>
